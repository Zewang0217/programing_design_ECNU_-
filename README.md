"# program-design" 

华东师范大学大一下学期 ———— 程序设计实训课程
习题集答案（ECNU Online judge）

+ 部分题目写有简略思路
+ 作业网址： https://acm.ecnu.edu.cn/contest/43/
+ 提示：每个cpp文件都有注释，需要手动去除。
+ [点击跳转到C++部分库的学习](C++学习.md)

# 题目列表

### 1013. 绝对值排序 

### 1014. Sort it… 

### 1015. 排序去重

 ### 1016. 键盘

 ### 1017. 成绩排序 

### 1018. 询问队员身高 

### 1019. 排序 

### 1020. 文献排序 

### 1021. 鞍点

+ 遍历每个矩阵元素，分别判断行列大小

 ### 1022. 数组排序 

+ unordered map 计算个数，键值对排序并存入vector容器中

### 1023. 学生信息处理 

+ 该代码只能通过测试一，无法通过测试二。尝试了多次没找到结果。若有通过者，希望指出

### 1024. 单词表

+ 使用unorded_map除去多余单词，用istringstream读取单词
+ 其实可以直接用vector排序，输出时排除重复项就好。此处是为了练习map的使用，所以代码较为复杂

###  1025. 商品推荐

###    1026. 成绩计算

###     1027. 发愁 

###   1028. 指数比例 

+ `cmath` 中的 `exp()` 用于计算指数 

###   1029. 字串非重复字符数排序 

###   1030. 素数个数排序 

+ 埃拉托斯特尼筛法
  ```cpp
  for (int i = 2; i * i <= end; ++i) {
      if (isPrimeArray[i]) {
          for (int j = i * i; j <= end; j += i) {
              isPrimeArray[j] = false;
          }
      }
  }
  ```

  + 逻辑： 把所有素数的倍数确定为非素数
  
+ 提示：可以提前计算素数个数，以防超出时间限制。

###    1031. HTTP与HTTPS

+ 使用 string 中函数 ， 详见 [ string ](C++学习.md#substr)

  

###    1032. 买书 

+ 提示：使用long long防止溢出

###    1033. 自修室

+ 定义不知大小的二位数组时，考虑vector的2D形式

###     1034. When I sort… 

+ cmp2用于还原排列顺序，以便按原顺序输出结果

###     1035. 文件排序

###     1036. Search Web Pages 

###     1037. 成绩排序 

###    1038. 极坐标排序

###     1039. 道路排序

###      1040. 按整数最高位的值排序 

###      1041. 闪卡销售

###      1042. Maya历日期的排序

###       1043. 字串排序 

###       1044. 按数据中1的位数排序

```cpp
// 统计整数二进制表示中 1 的个数
int countSetBits(long long n) {
    int count = 0;
    // 64 位整数
    for (int i = 0; i < 64; i++) {
        if (n & (1LL << i)) {
            count++;
        }
    }
    return count;
}
```



###      1045. Hosts排序

+ stringstream流式读取 分割字符串

```cpp
void parseIP(Pair& p) {
	stringstream ss(p.IP);
	string segment;
	int i = 0;
	while (getline(ss, segment, '.')) {
		p.octets[i++] = stoi(segment);
	}
}
```



###        1046. DNA 排序题

map

###        1047. 随机排序 

string find



###        1048. 行数据的排序

###         1049. 最小向量点积

###         1050. 字符排序 

###        1051. 分数链表排序

+ 冒泡排序

###         1052. KL排序

###         1053. 邮件地址排序

###         1054. Holes

###         1055. Pinhole Imaging 

###        1056. 重力加速度

###        1057. 链表整理 

###         1058. 起床 

###         1059. 火仙花数

###         1060. 查询

+ unordered_set

###          1061. 菱形 

###         1062. 孤独数 

###         1063. sunny的密码

###         1064. Hard to Believe, but True! 

+ 用algorithm的reverse函数反转字符串
+ 用string中的find、substr、erase截取整数

###        1065. Wavelet Compression 

+ 小波变换

  原始数据: 5 2 3 2 5 7 9 6
  第一步计算:
      s = (5+2) (3+2) (5+7) (9+6) -> 7 5 12 15
      d = (5-2) (3-2) (5-7) (9-6) -> 3 1 -2 3
  结果: 7 5 12 15 | 3 1 -2 3
  再对前半部分进行变换:
      s = (7+5) (12+15) -> 12 27
      d = (7-5) (12-15) -> 2 -3
  结果: 12 27 | 2 -3 | 3 1 -2 3
  再变换:
      s = (12+27) -> 39
      d = (12-27) -> -15
  最终变换结果: 39 -15 | 2 -3 | 3 1 -2 3

  + 核心：递归

  +  **逆变换步骤**

    **(1) 逆变换公式**

    已知：
    $$
    s(i) = a(2i-1) + a(2i)
    ~~~~~~~~~~
    d(i)=a(2i−1)−a(2i)
    $$
    可以推出：
    $$
    a(2i-1) = \frac{s(i) + d(i)}{2}
    ~~~~~~~~~~
    a(2i)= 
    2
    s(i)−d(i)
    ​
    $$
    **每一层逆变换时，我们需要用 `s(i)` 和 `d(i)` 还原 `a(2i-1)` 和 `a(2i)`。**
    
    **(2) 逆变换流程**
    
    1. **从最小的 `size = 2` 开始**，每次恢复 2 个元素
    2. **依次增加 `size = 4, 8, ...`，逐步恢复更长的数组**
    3. **直到恢复完整个数组**

###        1066. 达到回文数 

###        1067. 成绩统计

###         1068. 歌德巴赫猜想

+ 再次用到埃拉托斯特尼筛法

###         ### 1069. 买房子

###          ### 1070. 魔方阵

###          ### 1071. 数据密度 

+ 求最大公约数

欧几里得算法（辗转相除法）：

假设我们要求两个整数 `a` 和 `b`（`a >= b`）的最大公约数。

1. **基本原理**：
   欧几里得算法基于一个重要的数学原理，即两个整数 `a` 和 `b` 的最大公约数等于 `b` 和 `a` 除以 `b` 的余数的最大公约数。用数学公式表示为：`gcd(a, b) = gcd(b, a % b)`。
2. **具体步骤**：
   - 首先，将较大的数 `a` 除以较小的数 `b`，得到商和余数。例如，`a = kb + r`，其中 `k` 是商，`r` 是余数（`0 <= r < b`）。
   - 然后，根据上述原理，我们可以将求 `gcd(a, b)` 的问题转化为求 `gcd(b, r)` 的问题。因为任何能同时整除 `a` 和 `b` 的数，也一定能同时整除 `b` 和 `r`；反之亦然。
   - 重复这个过程，即不断用较小的数（原来的除数）去除上一步的余数，直到余数为 `0` 为止。当余数为 `0` 时，此时的除数就是原来两个数的最大公约数。

以下是用 C++ 代码实现的 `gcd` 函数，展示了欧几里得算法的具体过程：

```cpp
int gcd(int a, int b) {
    return b == 0? a : gcd(b, a % b);
}
```





在这个代码中：

- 如果 `b` 等于 `0`，说明已经除到余数为 `0` 了，此时 `a` 就是原来两个数的最大公约数，直接返回 `a`。
- 如果 `b` 不等于 `0`，则递归调用 `gcd` 函数，将 `b` 作为新的被除数，`a % b` 作为新的除数，继续计算最大公约数。

通过这种递归的方式，最终可以得到两个整数的最大公约数。

###  1072. 点名

 ### 1073. Familial Numbers

 ### 1074. 统计不同的最简真分数的个数

 ### 1075. 付钱

 ### 1076. 农场

 ### 1077. 3的倍数

 ### 1078. 数学手稿

 ### 1079. 判断 IP

 ### 1080. 卡片

### 1081. 替换

 ### 1082. ROT13加密和解密

### 1083. 计算n!右端0的个数(I)

##  打印题目

### 2822

